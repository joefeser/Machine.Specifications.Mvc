//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

using Machine.Specifications.Mvc.Specs.ActionResults;

namespace Machine.Specifications.Mvc.Specs
{
    using System;
    using System.Web.Mvc;
    using System.Web.Routing;

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_of_the_given_type_of_action_result_is_asked_if_it_is__of_that_type
    {
        static Exception exception;
        static object result;

        Because of = () => exception = Catch.Exception(() => result = new TestActionResult().ShouldBeA<TestActionResult>());

        It should_not_throw_an_exception = () => exception.ShouldBeNull();

        It should_allow_the_chaining_of_action_result_assertions = () => result.ShouldBeAssignableTo<ActionResultAnd<TestActionResult>>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_of_the_given_type_is_asked_if_it_is_of_that_type
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(() => new ViewResult().ShouldBeA<TestActionResult>());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_view_result_is_asked_if_it_is_a_view_result
    {
        static Exception exception;
        static object result;

        Because of = () => exception = Catch.Exception(() => result = new ViewResult().ShouldBeAView());

        It should_not_throw_an_exception = () => exception.ShouldBeNull();

        It should_allow_the_chaining_of_view_result_assertions = () => result.ShouldBeAssignableTo<ActionResultAnd<ViewResult>>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_a_view_result_is_asked_if_it_is_a_view_result 
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(()=> new RedirectToRouteResult("", null).ShouldBeAView());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_partial_view_result_is_asked_if_it_is_a_partial_view_result
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(() => new PartialViewResult().ShouldBeAPartialView());

        It should_not_throw_an_exception = () => exception.ShouldBeNull();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_a_partial_view_result_is_asked_if_it_is_a_partial_view_result 
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(()=> new RedirectToRouteResult("", null).ShouldBeAPartialView());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_view_result_is_asked_for_the_model
    {
        static Exception exception;
        static object result;
        static string model = "The model";
        static ActionResult viewResult; 

        Establish context = () => 
        {
            viewResult = new ViewResult() { ViewData = { Model = model } };
        };

        Because of = () => exception = Catch.Exception(() => result = viewResult.Model<string>());

        It should_throw_not_throw_an_exception = () => exception.ShouldBeNull();

        It should_return_the_model_as_the_specified_type = () => result.ShouldBeAssignableTo<string>();

        It should_return_the_correct_model = () => result.ShouldEqual(model);
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_a_view_result_is_asked_for_the_model
    {
        static Exception exception;
        static ActionResult redirectResult;

        Establish context = () =>
        {
            redirectResult = new RedirectResult("TheUrl");
        };

        Because of = () => exception = Catch.Exception(() => redirectResult.Model<string>());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_view_result_is_asked_for_the_model_of_the_wrong_type
    {
        static Exception exception;
        static int model = 1;
        static ActionResult viewResult;

        Establish context = () =>
        {
            viewResult = new ViewResult() { ViewData = { Model = model } };
        };

        Because of = () => exception = Catch.Exception(() => viewResult.Model<string>());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_redirect_to_route_result_is_asked_if_it_is_a_redirect_to_route_result
    {
        static Exception exception;
        static object result;

        Because of = () => exception = Catch.Exception(() => result = new RedirectToRouteResult("", null).ShouldBeARedirectToRoute());

        It should_not_throw_an_exception = () => exception.ShouldBeNull();

        It should_allow_the_chaining_of_redirect_to_route_result_assertions = () => result.ShouldBeAssignableTo<ActionResultAnd<RedirectToRouteResult>>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_a_redirect_to_route_result_is_asked_if_it_is_a_redirect_to_route_result
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(() => new ViewResult().ShouldBeARedirectToRoute());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_redirect_result_is_asked_if_it_is_a_redirect_result
    {
        static Exception exception;
        static object result;

        Because of = () => exception = Catch.Exception(() => result = new RedirectResult("TheUrl").ShouldBeARedirect());

        It should_not_throw_an_exception = () => exception.ShouldBeNull();

        It should_allow_the_chaining_of_redirect_result_assertions = () => result.ShouldBeAssignableTo<ActionResultAnd<RedirectResult>>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_a_redirect_result_is_asked_if_it_is_a_redirect_result
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(() => new ViewResult().ShouldBeARedirect());

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions), "Given an action redirects to another action on the same controller")]
    public class when_asking_if_a_redirect_occurs_to_that_same_controller_and_action
    {
        static Exception exception;
        static RedirectToRouteResult redirectToRouteResult;

        Establish context = () =>
        {
            redirectToRouteResult = new RedirectToRouteResult(new RouteValueDictionary(new { action = "Index" }));
        };

        Because of = () => exception = Catch.Exception(() => redirectToRouteResult.ShouldRedirectToAction<HomeController>(x => x.Index()));

        It should_not_throw_an_exception = () => exception.ShouldBeNull();
    }

    [Subject(typeof(ActionResultExtensions), "Given an action redirects to another action on a different controller")]
    public class when_asking_if_a_redirect_occurs_to_that_different_controller_and_action
    {
        static Exception exception;
        static RedirectToRouteResult redirectToRouteResult;

        Establish context = () =>
            {
                redirectToRouteResult = new RedirectToRouteResult(new RouteValueDictionary(new {controller = "Home", action = "Index"}));
            };

        Because of = () => exception = Catch.Exception(() => redirectToRouteResult.ShouldRedirectToAction<HomeController>(x => x.Index()));

        It should_not_throw_an_exception = () => exception.ShouldBeNull();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_redirect_result_is_asked_if_it_redirects_to_the_wrong_action_on_the_controller
    {
        static Exception exception;
        static RedirectToRouteResult redirectToRouteResult;

        Establish context = () =>
        {
            redirectToRouteResult = new RedirectToRouteResult(new RouteValueDictionary(new { controller = "Home", action = "List" }));
        };

        Because of = () => exception = Catch.Exception(() => redirectToRouteResult.ShouldRedirectToAction<HomeController>(x => x.Index()));

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_a_redirect_result_is_asked_if_it_redirects_to_the_wrong_controller
    {
        static Exception exception;
        static RedirectToRouteResult redirectToRouteResult;

        Establish context = () =>
        {
            redirectToRouteResult = new RedirectToRouteResult(new RouteValueDictionary(new { controller = "Person", action = "Index" }));
        };

        Because of = () => exception = Catch.Exception(() => redirectToRouteResult.ShouldRedirectToAction<HomeController>(x => x.Index()));

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }

    [Subject(typeof(ActionResultExtensions))]
    public class when_an_action_result_that_is_not_a_redirect_result_is_asked_if_it_redirects_to_an_action_on_a_controller
    {
        static Exception exception;

        Because of = () => exception = Catch.Exception(() => new ViewResult().ShouldRedirectToAction<HomeController>(x => x.Index()));

        It should_throw_an_exception = () => exception.ShouldBeAssignableTo<SpecificationException>();
    }


    internal class HomeController : System.Web.Mvc.Controller
    {
        public void Index()
        {
            throw new NotImplementedException();
        }

        public void List()
        {
            throw new NotImplementedException();
        }
    }
}   